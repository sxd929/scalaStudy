buildscript {
    repositories {
        jcenter()
        maven { url "https://plugins.gradle.org/m2/" }
        maven { url "https://oss.sonatype.org/content/repositories/releases" }
        maven { url 'http://repo.spring.io/plugins-release' }
    }
    dependencies {
        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.3'
        classpath 'org.github.ngbinh.scalastyle:gradle-scalastyle-plugin_2.11:0.8.2'
        classpath 'org.springframework.build.gradle:propdeps-plugin:0.0.7'
    }
}

plugins {
    id 'com.jfrog.artifactory' version '3.1.1'
}

apply plugin: 'com.jfrog.artifactory'
apply from: 'artifactory.gradle'

//noinspection GroovyAssignabilityCheck
apply plugin: 'scala'
apply plugin: 'idea'
apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: 'scalaStyle'
apply plugin: 'maven'
apply plugin: 'maven-publish'
apply plugin: 'propdeps'
apply plugin: 'propdeps-idea'
apply plugin: 'com.jfrog.artifactory'
apply plugin: 'java'

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

ext {
scalaVersion = '2.11'
scalaVersionRevision = '8'
junitVersion = '4.11'
jacksonVersion = '2.7.7'
sparkVersion = '2.0.0'
isSnapshot = { version ->
    return version.toString().toLowerCase().endsWith("snapshot")
}
}

//noinspection GroovyAssignabilityCheck
configurations.all {
// Don't cache changing modules at all
resolutionStrategy.cacheChangingModulesFor 0, 'seconds'

// Enforce jackson 2.x.x to 2.7.7 (1.x.x remains the same) in order to overcome the following issue:
// https://github.com/FasterXML/jackson-module-scala/issues/233
resolutionStrategy.force "com.fasterxml.jackson.core:jackson-annotations:$jacksonVersion",
	"com.fasterxml.jackson.core:jackson-core:$jacksonVersion",
	"com.fasterxml.jackson.core:jackson-databind:$jacksonVersion",
	"com.fasterxml.jackson.datatype:jackson-datatype-jdk8:$jacksonVersion",
	"com.fasterxml.jackson.datatype:jackson-datatype-jsr310:$jacksonVersion",
	"com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:$jacksonVersion",
	"com.fasterxml.jackson.module:jackson-module-paranamer:$jacksonVersion",
	"com.fasterxml.jackson.module:jackson-module-scala_$scalaVersion:$jacksonVersion"

}
//noinspection GroovyAssignabilityCheck
configurations {
scalaLibrary
scalaCompiler
}

idea {
module {
    jdkName = '1.8'
    inheritOutputDirs = false
    outputDir = file("build/classes/main")
    testOutputDir = file("build/classes/test")
}
}

//noinspection GroovyAssignabilityCheck
dependencies {
scalaLibrary "org.scala-lang:scala-library:$scalaVersion.$scalaVersionRevision"
scalaCompiler "org.scala-lang:scala-compiler:$scalaVersion.$scalaVersionRevision"
compile "org.scala-lang:scala-library:$scalaVersion.$scalaVersionRevision"

compile "org.apache.spark:spark-core_$scalaVersion:$sparkVersion"
compile "org.apache.spark:spark-mllib_$scalaVersion:$sparkVersion"
compile "org.apache.spark:spark-sql_$scalaVersion:$sparkVersion"
compile "com.databricks:spark-avro_2.11:3.0.1"

testCompile "org.scalatest:scalatest_$scalaVersion:2.2.6"
testCompile "junit:junit:${junitVersion}"

compile "com.github.tototoshi:scala-csv_2.10:1.3.3"
}

tasks.withType(ScalaCompile) {
configure(scalaCompileOptions.forkOptions) {
    memoryMaximumSize = '1g'
    jvmArgs = ['-XX:MaxMetaspaceSize=256m']
}
}
compileScala {
scalaCompileOptions.additionalParameters = ["-optimize"]
}
compileTestScala {
scalaCompileOptions.additionalParameters = ["-Yrangepos"]
}
[compileJava, compileTestJava]*.options.collect { options -> options.encoding = 'UTF-8' }

//noinspection GroovyAssignabilityCheck
jar {
baseName = "${rootProject.name}"
}

shadowJar {
zip64 = true
exclude 'META-INF/**'
baseName = project.name + '-with-dependencies'
}

task stage {
dependsOn shadowJar
}

scalaStyle {
configLocation = "scalastyle-config.xml"
includeTestSourceDirectory = true
source = "src/main/scala"
testSource = "src/test/scala"
}
compileScala.dependsOn(scalaStyle)

task assembleApplications(dependsOn: jar) {
doLast {
    copy {
	from configurations.runtime
	into "$buildDir/archive/lib"
    }
    copy {
	from jar.outputs.files
	into "$buildDir/archive"
    }
}
}

task runMain(type: JavaExec) {
description 'run a main class, i.e.: runMain -Dmain=MyMainClass -Dargs="arg1 arg2 arg3"'
main = System.getProperty("main")
classpath = sourceSets.main.runtimeClasspath
//noinspection GroovyAssignabilityCheck
systemProperties = System.getProperties()
args = System.getProperty("args", "") == "" ? new LinkedList<String>() : Arrays.asList(System.getProperty("args").split(" "))
}

task repl(type: JavaExec) {
description 'Start Scala repl.'
main = "scala.tools.nsc.MainGenericRunner"
classpath = sourceSets.main.runtimeClasspath
standardInput System.in
//noinspection GroovyAssignabilityCheck
args '-usejavacp'
}

task classpath << {
//noinspection GroovyAssignabilityCheck
description 'Print project classpath.'
println sourceSets.main.runtimeClasspath.asPath
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.13'
    description "Sets the Gradle wrapper version to $gradleVersion."
}

artifactoryPublish {
    doFirst {
        println "Overriding repository based on project version (snapshot/release) version=${project.version}"
        clientConfig.publisher.repoKey = "libs-${project.version.endsWith('-SNAPSHOT') ? 'snapshots' : 'releases'}-local"
        println("Publishing to ${clientConfig.publisher.repoKey}")
    }
}

apply from: 'tests.gradle'

jar.baseName = "$rootProject.name-$project.name"

publishing {
publications {
    mavenJava(MavenPublication) {
	artifactId "${jar.baseName}_$scalaVersion"
	from components.java
	artifact sourcesJar { classifier "sources" }
    }
}
}

task sourcesJar(type: Jar, dependsOn: classes) {
classifier = 'sources'
from sourceSets.main.allSource
}
sourcesJar.baseName = jar.baseName

artifacts {
archives sourcesJar
}

artifactoryPublish.dependsOn(jar, sourcesJar)

// Skip publishing the root project
artifactoryPublish.skip = true
